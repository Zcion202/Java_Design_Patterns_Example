# 抽象工厂模式
## 背景
工厂方法模式每创建一个产品类就需要创建其对应的工厂类，这会导致系统复杂度过高。可以考虑将相关的产品类组成一个**产品族**，由一个工厂类来实现产品族的生产

## 需求说明
设置一套皮肤库，实现组件库的风格设计。皮肤库有spring、summer两种风格，组件库有button、TextField两种组件

## 例子说明
1. SpringSkinFactory:生产spring风格的组件
2. SummerSkinFactory:生产summer风格的组件
3. 抽象产品类button和TextField定义为接口，不同风格在实现各自的组件时需要实现这个接口
4. SkinFactory是工厂类的接口

## 一些概念
1. 产品族：由同一工厂生产的，位于不用产品等级结构的产品属于同一产品族
2. 产品结构等级：同一产品的继承结构（SpringButton和SummerButton各自继承了Button接口）

## 总结
1. 优点
    - 无需对每个产品设计相应的工厂类，相较于工厂方法模式，该模式减少了系统的复杂度
    - 添加新的产品族较为方便，无需修改源码，符合**开闭原则**
2. 缺点
    - 扩展产品族很方便，但扩展产品等级结构很麻烦，会破坏开闭原则，属于**开闭原则的倾斜性**（如果这时添加一个新的组件，就需要实现spring、summer风格的新组件，这涉及到源码的修改）
3. 适用场景
    - 一个系统不依赖于产品类实例如何被创建的细节，只关注如何使用产品
    - 系统中有多个产品族，可以通过修改配置文件来改变产品族
    - 产品等级结构稳定，后续不会添加新的产品等级结构